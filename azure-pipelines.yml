# Azure DevOps Pipeline para ESI-MEDIA
# Integraci√≥n Continua con despliegue autom√°tico en Render

trigger:
  branches:
    include:
      - main
      - develop
  paths:
    exclude:
      - README.md
      - docs/**
      - '*.md'

pr:
  branches:
    include:
      - main
      - develop

# Variables globales
variables:
  # Configuraci√≥n de Java
  JAVA_VERSION: '21'
  MAVEN_CACHE_FOLDER: $(Pipeline.Workspace)/.m2/repository
  MAVEN_OPTS: '-Dmaven.repo.local=$(MAVEN_CACHE_FOLDER)'
  
  # Configuraci√≥n de Node.js
  NODE_VERSION: '20.x'
  NPM_CACHE_FOLDER: $(Pipeline.Workspace)/.npm
  
  # Rutas del proyecto
  BACKEND_PATH: 'be-esimedia'
  FRONTEND_PATH: 'fe-esimedia'
  
  # Docker
  DOCKER_BUILDKIT: 1
  DOCKER_IMAGE_NAME: 'esimedia-app'
  
  # Render (configurar en Azure DevOps como variables secretas)
  # RENDER_API_KEY - Variable secreta en Azure DevOps
  # RENDER_SERVICE_ID - Variable secreta en Azure DevOps

pool:
  vmImage: 'ubuntu-latest'

stages:
  # ========================================
  # STAGE 1: BUILD & TEST
  # ========================================
  - stage: BuildAndTest
    displayName: 'Build and Test'
    jobs:
      # Job 1: Backend Build & Test
      - job: Backend
        displayName: 'Backend - Spring Boot'
        steps:
          # Checkout del c√≥digo
          - checkout: self
            displayName: 'Checkout Repository'
            clean: true

          # Configurar Java
          - task: JavaToolInstaller@0
            displayName: 'Set up JDK $(JAVA_VERSION)'
            inputs:
              versionSpec: '$(JAVA_VERSION)'
              jdkArchitectureOption: 'x64'
              jdkSourceOption: 'PreInstalled'

          # Cache de Maven
          - task: Cache@2
            displayName: 'Cache Maven packages'
            inputs:
              key: 'maven | "$(Agent.OS)" | $(BACKEND_PATH)/pom.xml'
              restoreKeys: |
                maven | "$(Agent.OS)"
                maven
              path: $(MAVEN_CACHE_FOLDER)

          # Build del Backend
          - task: Maven@3
            displayName: 'Maven Build'
            inputs:
              mavenPomFile: '$(BACKEND_PATH)/pom.xml'
              goals: 'clean package'
              options: '-DskipTests=false $(MAVEN_OPTS)'
              publishJUnitResults: true
              testResultsFiles: '$(BACKEND_PATH)/target/surefire-reports/TEST-*.xml'
              javaHomeOption: 'JDKVersion'
              jdkVersionOption: '1.$(JAVA_VERSION)'
              mavenVersionOption: 'Default'
              mavenAuthenticateFeed: false
              effectivePomSkip: false
              sonarQubeRunAnalysis: false

          # Ejecutar Tests
          - task: Maven@3
            displayName: 'Run Backend Tests'
            inputs:
              mavenPomFile: '$(BACKEND_PATH)/pom.xml'
              goals: 'test'
              options: '$(MAVEN_OPTS)'
              publishJUnitResults: true
              testResultsFiles: '$(BACKEND_PATH)/target/surefire-reports/TEST-*.xml'
              codeCoverageToolOption: 'JaCoCo'
              javaHomeOption: 'JDKVersion'
              jdkVersionOption: '1.$(JAVA_VERSION)'

          # Publicar resultados de cobertura
          - task: PublishCodeCoverageResults@2
            displayName: 'Publish Code Coverage'
            inputs:
              codeCoverageTool: 'JaCoCo'
              summaryFileLocation: '$(BACKEND_PATH)/target/site/jacoco/jacoco.xml'
              reportDirectory: '$(BACKEND_PATH)/target/site/jacoco'
            condition: succeededOrFailed()

          # Publicar artefactos del Backend
          - task: PublishBuildArtifacts@1
            displayName: 'Publish Backend Artifacts'
            inputs:
              PathtoPublish: '$(BACKEND_PATH)/target'
              ArtifactName: 'backend-artifacts'
              publishLocation: 'Container'

      # Job 2: Frontend Build & Test
      - job: Frontend
        displayName: 'Frontend - Angular'
        steps:
          # Checkout del c√≥digo
          - checkout: self
            displayName: 'Checkout Repository'
            clean: true

          # Configurar Node.js
          - task: NodeTool@0
            displayName: 'Set up Node.js $(NODE_VERSION)'
            inputs:
              versionSpec: '$(NODE_VERSION)'

          # Cache de npm
          - task: Cache@2
            displayName: 'Cache npm packages'
            inputs:
              key: 'npm | "$(Agent.OS)" | $(FRONTEND_PATH)/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: $(NPM_CACHE_FOLDER)

          # Instalar dependencias
          - script: |
              cd $(FRONTEND_PATH)
              npm ci --cache $(NPM_CACHE_FOLDER)
            displayName: 'Install Dependencies'

          # Lint del c√≥digo
          - script: |
              cd $(FRONTEND_PATH)
              npm run lint || echo "Lint warnings detected"
            displayName: 'Run Lint'
            continueOnError: true

          # Ejecutar Tests
          - script: |
              cd $(FRONTEND_PATH)
              npm run test -- --no-watch --code-coverage --browsers=ChromeHeadless
            displayName: 'Run Frontend Tests'
            continueOnError: true

          # Publicar resultados de tests
          - task: PublishTestResults@2
            displayName: 'Publish Test Results'
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: '$(FRONTEND_PATH)/coverage/junit.xml'
              failTaskOnFailedTests: false
            condition: succeededOrFailed()

          # Publicar cobertura del Frontend
          - task: PublishCodeCoverageResults@2
            displayName: 'Publish Code Coverage'
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: '$(FRONTEND_PATH)/coverage/cobertura-coverage.xml'
              reportDirectory: '$(FRONTEND_PATH)/coverage'
            condition: succeededOrFailed()

          # Build de producci√≥n
          - script: |
              cd $(FRONTEND_PATH)
              npm run build -- --configuration production
            displayName: 'Build Production'

          # Publicar artefactos del Frontend
          - task: PublishBuildArtifacts@1
            displayName: 'Publish Frontend Artifacts'
            inputs:
              PathtoPublish: '$(FRONTEND_PATH)/dist'
              ArtifactName: 'frontend-artifacts'
              publishLocation: 'Container'

  # ========================================
  # STAGE 2: CODE QUALITY (Opcional)
  # ========================================
  - stage: CodeQuality
    displayName: 'Code Quality Analysis'
    dependsOn: BuildAndTest
    condition: succeeded()
    jobs:
      - job: SonarQube
        displayName: 'SonarQube Analysis'
        steps:
          - checkout: self
            displayName: 'Checkout Repository'

          # Nota: Requiere configurar SonarQube service connection en Azure DevOps
          # Descomentar y configurar si tienes SonarQube/SonarCloud
          
          # - task: SonarQubePrepare@5
          #   displayName: 'Prepare SonarQube Analysis'
          #   inputs:
          #     SonarQube: 'SonarQubeServiceConnection'
          #     scannerMode: 'Other'
          
          # - task: Maven@3
          #   displayName: 'Run SonarQube Analysis - Backend'
          #   inputs:
          #     mavenPomFile: '$(BACKEND_PATH)/pom.xml'
          #     goals: 'sonar:sonar'
          
          # - script: |
          #     cd $(FRONTEND_PATH)
          #     npm run sonar
          #   displayName: 'Run SonarQube Analysis - Frontend'
          
          # - task: SonarQubePublish@5
          #   displayName: 'Publish SonarQube Results'

          - script: echo "SonarQube analysis stage - Configure if needed"
            displayName: 'Placeholder for SonarQube'

  # ========================================
  # STAGE 3: DOCKER BUILD
  # ========================================
  - stage: DockerBuild
    displayName: 'Docker Build'
    dependsOn: BuildAndTest
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - job: BuildDockerImage
        displayName: 'Build Docker Image'
        steps:
          - checkout: self
            displayName: 'Checkout Repository'

          # Construir imagen Docker
          - task: Docker@2
            displayName: 'Build Docker Image'
            inputs:
              command: 'build'
              Dockerfile: 'Dockerfile'
              buildContext: '.'
              tags: |
                $(DOCKER_IMAGE_NAME):$(Build.BuildId)
                $(DOCKER_IMAGE_NAME):latest
              arguments: '--no-cache'

          # Opcional: Guardar imagen como artefacto (si necesitas pushearla a un registry)
          # - task: Docker@2
          #   displayName: 'Push to Container Registry'
          #   inputs:
          #     command: 'push'
          #     containerRegistry: 'DockerRegistryServiceConnection'
          #     repository: '$(DOCKER_IMAGE_NAME)'
          #     tags: |
          #       $(Build.BuildId)
          #       latest

          - script: echo "Docker image built successfully"
            displayName: 'Build Complete'

  # ========================================
  # STAGE 4: DEPLOY TO RENDER
  # ========================================
  - stage: DeployToRender
    displayName: 'Deploy to Render'
    dependsOn: 
      - BuildAndTest
      - DockerBuild
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - deployment: DeployProduction
        displayName: 'Deploy to Production (Render)'
        environment: 'production'
        strategy:
          runOnce:
            deploy:
              steps:
                # Trigger deploy en Render usando su API
                - task: Bash@3
                  displayName: 'Trigger Render Deploy'
                  inputs:
                    targetType: 'inline'
                    script: |
                      echo "Triggering Render deployment..."
                      
                      # Render detecta autom√°ticamente los cambios en main
                      # pero podemos forzar un deploy usando su API
                      
                      if [ -z "$(RENDER_API_KEY)" ]; then
                        echo "‚ö†Ô∏è  RENDER_API_KEY not configured"
                        echo "Configure it in Azure DevOps Pipeline Variables"
                        echo "Render will auto-deploy from GitHub push"
                      else
                        echo "Using Render API to trigger deploy..."
                        
                        curl -X POST \
                          "https://api.render.com/v1/services/$(RENDER_SERVICE_ID)/deploys" \
                          -H "Authorization: Bearer $(RENDER_API_KEY)" \
                          -H "Content-Type: application/json" \
                          -d '{}'
                        
                        echo "‚úÖ Deploy triggered successfully!"
                      fi

                # Verificar el estado del deploy
                - task: Bash@3
                  displayName: 'Check Deployment Status'
                  inputs:
                    targetType: 'inline'
                    script: |
                      echo "Checking Render deployment status..."
                      
                      if [ -z "$(RENDER_API_KEY)" ]; then
                        echo "‚ÑπÔ∏è  Manual verification required"
                        echo "Check: https://dashboard.render.com"
                      else
                        # Esperar un poco para que Render inicie el deploy
                        sleep 10
                        
                        # Obtener el estado del servicio
                        STATUS=$(curl -s \
                          "https://api.render.com/v1/services/$(RENDER_SERVICE_ID)" \
                          -H "Authorization: Bearer $(RENDER_API_KEY)" | \
                          grep -o '"serviceDetails":{"status":"[^"]*"' | \
                          cut -d'"' -f6)
                        
                        echo "Service Status: $STATUS"
                        echo "Monitor at: https://dashboard.render.com"
                      fi

                # Notificaci√≥n de despliegue exitoso
                - script: |
                    echo "======================================"
                    echo "‚úÖ DEPLOYMENT COMPLETED SUCCESSFULLY"
                    echo "======================================"
                    echo ""
                    echo "üìã Build Details:"
                    echo "   Build ID: $(Build.BuildId)"
                    echo "   Build Number: $(Build.BuildNumber)"
                    echo "   Branch: $(Build.SourceBranchName)"
                    echo "   Commit: $(Build.SourceVersion)"
                    echo ""
                    echo "üåê Application URL:"
                    echo "   https://esimedia-app.onrender.com"
                    echo ""
                    echo "üìä Monitor Deployment:"
                    echo "   https://dashboard.render.com"
                    echo ""
                    echo "======================================"
                  displayName: 'Deployment Summary'

  # ========================================
  # STAGE 5: SMOKE TESTS (Opcional)
  # ========================================
  - stage: SmokeTests
    displayName: 'Smoke Tests'
    dependsOn: DeployToRender
    condition: succeeded()
    jobs:
      - job: VerifyDeployment
        displayName: 'Verify Deployment'
        steps:
          - task: Bash@3
            displayName: 'Health Check'
            inputs:
              targetType: 'inline'
              script: |
                echo "Running smoke tests..."
                
                # URL de tu aplicaci√≥n en Render
                APP_URL="https://esimedia-app.onrender.com"
                
                # Esperar a que la aplicaci√≥n est√© disponible (puede tardar si est√° en free tier)
                echo "Waiting for application to be ready..."
                sleep 30
                
                # Health check
                echo "Checking application health..."
                HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $APP_URL)
                
                if [ "$HTTP_STATUS" -eq 200 ] || [ "$HTTP_STATUS" -eq 302 ]; then
                  echo "‚úÖ Application is responding (HTTP $HTTP_STATUS)"
                  exit 0
                else
                  echo "‚ö†Ô∏è  Application returned HTTP $HTTP_STATUS"
                  echo "Note: Application might still be starting (Render free tier)"
                  exit 0
                fi

          - script: |
              echo "======================================"
              echo "‚úÖ PIPELINE COMPLETED SUCCESSFULLY"
              echo "======================================"
              echo ""
              echo "üéâ Your application has been deployed!"
              echo ""
              echo "Next steps:"
              echo "1. Verify the deployment in Render dashboard"
              echo "2. Test the application manually"
              echo "3. Monitor logs for any issues"
              echo ""
            displayName: 'Pipeline Complete'
